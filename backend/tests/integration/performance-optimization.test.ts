import { describe, it, expect, beforeEach, afterEach } from 'vitest';
import { OptimizedScheduleGenerator } from '../../src/services/OptimizedScheduleGenerator';
import { PerformanceMonitor } from '../../src/services/PerformanceMonitor';
import { CacheService } from '../../src/services/CacheService';
import { ErrorRecoveryService } from '../../src/services/ErrorRecoveryService';
import { Course } from '../../src/models/Course';
import { Teacher } from '../../src/models/Teacher';
import { Group } from '../../src/models/Group';

describe('Performance & Optimization Integration Tests', () => {
  let generator: OptimizedScheduleGenerator;
  let performanceMonitor: PerformanceMonitor;
  let cacheService: CacheService;
  let errorRecovery: ErrorRecoveryService;
  let mockCourses: Course[];
  let mockTeachers: Teacher[];
  let mockGroups: Group[];

  beforeEach(() => {
    generator = new OptimizedScheduleGenerator();
    performanceMonitor = new PerformanceMonitor();
    cacheService = new CacheService();
    errorRecovery = new ErrorRecoveryService();

    // Create comprehensive test data
    mockTeachers = Array.from({ length: 10 }, (_, i) => ({
      id: `teacher_${i}`,
      name: `Teacher ${i}`,
      email: `teacher${i}@school.com`,
      specializations: [`subject_${i % 3}`],
      maxHoursPerWeek: 40,
      preferredTimeSlots: [],
      createdAt: new Date(),
      updatedAt: new Date()
    }));

    mockGroups = Array.from({ length: 15 }, (_, i) => ({
      id: `group_${i}`,
      name: `Group ${i}`,
      level: `Level ${Math.floor(i / 5) + 1}`,
      maxStudents: 30,
      currentStudents: 25 + (i % 5),
      createdAt: new Date(),
      updatedAt: new Date()
    }));

    mockCourses = Array.from({ length: 25 }, (_, i) => ({
      id: `course_${i}`,
      name: `Course ${i}`,
      code: `C${i.toString().padStart(3, '0')}`,
      credits: 3 + (i % 3),
      teacherId: mockTeachers[i % mockTeachers.length].id,
      groupIds: [mockGroups[i % mockGroups.length].id],
      weeklyHours: 2 + (i % 3),
      createdAt: new Date(),
      updatedAt: new Date()
    }));\n  });\n\n  afterEach(() => {\n    cacheService.clearAll();\n    cacheService.destroy();\n  });\n\n  describe('Performance Monitoring Integration', () => {\n    it('should monitor schedule generation performance', async () => {\n      const constraints = {\n        maxLessonsPerDay: 8,\n        lessonDuration: 45,\n        breakDuration: 15,\n        maxHoursPerWeek: 40\n      };\n\n      const operationId = 'perf_test_schedule_gen';\n      performanceMonitor.startTiming(operationId, 'schedule_generation');\n\n      const schedule = await generator.generateOptimizedSchedule(\n        mockCourses,\n        mockTeachers,\n        mockGroups,\n        constraints\n      );\n\n      const metrics = performanceMonitor.endTiming(operationId, 'schedule_generation', true, {\n        courseCount: mockCourses.length,\n        teacherCount: mockTeachers.length,\n        groupCount: mockGroups.length\n      });\n\n      expect(schedule).toBeDefined();\n      expect(schedule.lessons).toBeDefined();\n      expect(metrics).toBeDefined();\n      expect(metrics!.duration).toBeLessThan(5000); // 5 second threshold\n      expect(metrics!.operation).toBe('schedule_generation');\n    });\n\n    it('should track memory usage during intensive operations', async () => {\n      const initialMemory = performanceMonitor.getCurrentMemoryUsage();\n      \n      // Perform multiple schedule generations\n      for (let i = 0; i < 5; i++) {\n        await generator.generateOptimizedSchedule(\n          mockCourses,\n          mockTeachers,\n          mockGroups,\n          { maxLessonsPerDay: 6, lessonDuration: 45 }\n        );\n      }\n\n      const finalMemory = performanceMonitor.getCurrentMemoryUsage();\n      const memoryIncrease = finalMemory.heapUsed - initialMemory.heapUsed;\n      \n      // Memory increase should be reasonable (less than 100MB)\n      expect(memoryIncrease).toBeLessThan(100 * 1024 * 1024);\n      expect(performanceMonitor.isMemoryPressureHigh()).toBe(false);\n    });\n\n    it('should generate comprehensive performance reports', async () => {\n      // Generate some operations for reporting\n      for (let i = 0; i < 3; i++) {\n        await performanceMonitor.timeFunction(\n          'test_operation',\n          async () => {\n            await new Promise(resolve => setTimeout(resolve, 10));\n            return `result_${i}`;\n          },\n          { iteration: i }\n        );\n      }\n\n      const report = performanceMonitor.generateReport();\n      \n      expect(report.summary).toBeDefined();\n      expect(report.operations).toBeDefined();\n      expect(report.alerts).toBeDefined();\n      expect(report.summary.totalOperations).toBeGreaterThan(0);\n      expect(report.operations.some(op => op.operation === 'test_operation')).toBe(true);\n    });\n  });\n\n  describe('Caching Integration', () => {\n    it('should cache schedule generation results', async () => {\n      const cacheKey = 'test_schedule_1';\n      const constraints = { maxLessonsPerDay: 6, lessonDuration: 45 };\n      \n      // First generation (not cached)\n      const schedule1 = await generator.generateOptimizedSchedule(\n        mockCourses,\n        mockTeachers,\n        mockGroups,\n        constraints\n      );\n      \n      // Cache the result\n      cacheService.set('schedule', cacheKey, schedule1, 60000); // 1 minute TTL\n      \n      // Retrieve from cache\n      const cachedSchedule = cacheService.get('schedule', cacheKey);\n      \n      expect(cachedSchedule).toBeDefined();\n      expect(cachedSchedule.id).toBe(schedule1.id);\n      expect(cacheService.has('schedule', cacheKey)).toBe(true);\n    });\n\n    it('should handle different cache types appropriately', () => {\n      const testData = {\n        course: { id: 'c1', name: 'Test Course' },\n        teacher: { id: 't1', name: 'Test Teacher' },\n        group: { id: 'g1', name: 'Test Group' },\n        lesson: { id: 'l1', courseId: 'c1' },\n        metadata: { version: '1.0', lastUpdate: Date.now() }\n      };\n\n      // Set data in different caches\n      Object.entries(testData).forEach(([type, data]) => {\n        cacheService.set(type, `test_${type}`, data);\n      });\n\n      // Verify all data is cached\n      Object.keys(testData).forEach(type => {\n        expect(cacheService.has(type, `test_${type}`)).toBe(true);\n        expect(cacheService.get(type, `test_${type}`)).toBeDefined();\n      });\n\n      // Check cache statistics\n      const allStats = cacheService.getAllStats();\n      expect(Object.keys(allStats)).toEqual(\n        expect.arrayContaining(['course', 'teacher', 'group', 'lesson', 'metadata'])\n      );\n    });\n\n    it('should generate cache health reports', () => {\n      // Add some data to caches\n      for (let i = 0; i < 10; i++) {\n        cacheService.set('course', `course_${i}`, { id: `c${i}`, name: `Course ${i}` });\n        cacheService.get('course', `course_${i}`); // Generate hits\n      }\n      \n      // Try to get non-existent data (generate misses)\n      for (let i = 10; i < 15; i++) {\n        cacheService.get('course', `course_${i}`);\n      }\n\n      const healthReport = cacheService.getHealthReport();\n      \n      expect(healthReport.overall).toBeDefined();\n      expect(healthReport.byType).toBeDefined();\n      expect(healthReport.recommendations).toBeDefined();\n      expect(healthReport.overall.totalHitRate).toBeGreaterThan(0);\n      expect(healthReport.byType.course).toBeDefined();\n      expect(healthReport.byType.course.stats.hits).toBeGreaterThan(0);\n    });\n  });\n\n  describe('Error Recovery Integration', () => {\n    it('should recover from transient failures with retry logic', async () => {\n      let attemptCount = 0;\n      const flakyOperation = async () => {\n        attemptCount++;\n        if (attemptCount < 3) {\n          throw new Error('Transient failure');\n        }\n        return 'success';\n      };\n\n      const result = await errorRecovery.executeWithRecovery(\n        flakyOperation,\n        {\n          operation: 'flaky_test',\n          timestamp: Date.now()\n        },\n        {\n          maxRetries: 3,\n          retryDelay: 100,\n          exponentialBackoff: false\n        }\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.result).toBe('success');\n      expect(result.retryAttempt).toBe(2); // Third attempt (0-indexed)\n      expect(attemptCount).toBe(3);\n    });\n\n    it('should implement circuit breaker pattern', async () => {\n      const alwaysFailingOperation = async () => {\n        throw new Error('Always fails');\n      };\n\n      const context = {\n        operation: 'circuit_breaker_test',\n        timestamp: Date.now()\n      };\n\n      const strategy = {\n        maxRetries: 1,\n        retryDelay: 10,\n        circuitBreakerThreshold: 3,\n        circuitBreakerTimeout: 1000\n      };\n\n      // Execute failing operations to trigger circuit breaker\n      for (let i = 0; i < 5; i++) {\n        const result = await errorRecovery.executeWithRecovery(\n          alwaysFailingOperation,\n          { ...context, operation: `${context.operation}_${i}` },\n          strategy\n        );\n        expect(result.success).toBe(false);\n      }\n\n      const errorStats = errorRecovery.getErrorStats();\n      expect(errorStats.totalErrors).toBeGreaterThan(0);\n      \n      // Check if any circuit breakers are open\n      const openCircuits = Object.values(errorStats.circuitBreakerStatus)\n        .filter(status => status.state === 'open');\n      expect(openCircuits.length).toBeGreaterThan(0);\n    });\n\n    it('should execute with fallback strategy', async () => {\n      const primaryOperation = async () => {\n        throw new Error('Primary failed');\n      };\n\n      const fallbackOperation = async () => {\n        return 'fallback_result';\n      };\n\n      const result = await errorRecovery.executeWithFallback(\n        primaryOperation,\n        fallbackOperation,\n        {\n          operation: 'fallback_test',\n          timestamp: Date.now()\n        }\n      );\n\n      expect(result.success).toBe(true);\n      expect(result.result).toBe('fallback_result');\n      expect(result.recoveryStrategy).toBe('fallback-success');\n    });\n\n    it('should generate error recovery reports', async () => {\n      // Generate some errors for reporting\n      for (let i = 0; i < 3; i++) {\n        await errorRecovery.executeWithRecovery(\n          async () => {\n            throw new Error(`Test error ${i}`);\n          },\n          {\n            operation: 'error_reporting_test',\n            timestamp: Date.now()\n          },\n          { maxRetries: 1, retryDelay: 10 }\n        );\n      }\n\n      const report = errorRecovery.generateReport();\n      \n      expect(report.errorStats).toBeDefined();\n      expect(report.recommendations).toBeDefined();\n      expect(report.healthStatus).toBeDefined();\n      expect(report.errorStats.totalErrors).toBeGreaterThan(0);\n      expect(report.recommendations.length).toBeGreaterThan(0);\n    });\n  });\n\n  describe('End-to-End Performance Integration', () => {\n    it('should handle complete workflow with monitoring, caching, and error recovery', async () => {\n      const workflow = async () => {\n        // Step 1: Check cache first\n        const cacheKey = 'e2e_test_schedule';\n        let cachedResult = cacheService.get('schedule', cacheKey);\n        \n        if (cachedResult) {\n          return cachedResult;\n        }\n\n        // Step 2: Generate with performance monitoring\n        const result = await performanceMonitor.timeFunction(\n          'e2e_schedule_generation',\n          async () => {\n            return await generator.generateOptimizedSchedule(\n              mockCourses,\n              mockTeachers,\n              mockGroups,\n              { maxLessonsPerDay: 6, lessonDuration: 45 }\n            );\n          },\n          { workflowStep: 'generation' }\n        );\n\n        // Step 3: Cache the result\n        cacheService.set('schedule', cacheKey, result.result, 300000); // 5 minutes\n        \n        return result.result;\n      };\n\n      // Execute with error recovery\n      const finalResult = await errorRecovery.executeWithRecovery(\n        workflow,\n        {\n          operation: 'e2e_workflow',\n          timestamp: Date.now(),\n          metadata: { testType: 'integration' }\n        },\n        {\n          maxRetries: 2,\n          retryDelay: 500\n        }\n      );\n\n      expect(finalResult.success).toBe(true);\n      expect(finalResult.result).toBeDefined();\n      expect(finalResult.result.lessons).toBeDefined();\n      \n      // Verify cache was populated\n      expect(cacheService.has('schedule', 'e2e_test_schedule')).toBe(true);\n      \n      // Verify performance metrics were recorded\n      const perfStats = performanceMonitor.getAggregatedStats('e2e_schedule_generation');\n      expect(perfStats.totalOperations).toBeGreaterThan(0);\n      \n      // Second execution should use cache (faster)\n      const startTime = Date.now();\n      const cachedResult = await errorRecovery.executeWithRecovery(\n        workflow,\n        {\n          operation: 'e2e_workflow_cached',\n          timestamp: Date.now()\n        }\n      );\n      const cachedExecutionTime = Date.now() - startTime;\n      \n      expect(cachedResult.success).toBe(true);\n      expect(cachedExecutionTime).toBeLessThan(100); // Should be very fast from cache\n    });\n\n    it('should maintain performance under concurrent load', async () => {\n      const concurrentOperations = Array.from({ length: 10 }, (_, i) => {\n        return performanceMonitor.timeFunction(\n          'concurrent_generation',\n          async () => {\n            return await generator.generateOptimizedSchedule(\n              mockCourses.slice(0, 5), // Smaller dataset for faster execution\n              mockTeachers.slice(0, 3),\n              mockGroups.slice(0, 5),\n              { maxLessonsPerDay: 4, lessonDuration: 45 }\n            );\n          },\n          { concurrentIndex: i }\n        );\n      });\n\n      const startTime = Date.now();\n      const results = await Promise.all(concurrentOperations);\n      const totalTime = Date.now() - startTime;\n\n      // All operations should succeed\n      expect(results.every(r => r.result.lessons !== undefined)).toBe(true);\n      \n      // Total time should be reasonable (less than 10 seconds for 10 concurrent operations)\n      expect(totalTime).toBeLessThan(10000);\n      \n      // Average operation time should be acceptable\n      const avgTime = results.reduce((sum, r) => sum + r.metrics.duration, 0) / results.length;\n      expect(avgTime).toBeLessThan(3000); // 3 seconds average\n      \n      // Check memory usage hasn't spiked\n      expect(performanceMonitor.isMemoryPressureHigh()).toBe(false);\n    });\n  });\n\n  describe('System Health Monitoring', () => {\n    it('should provide comprehensive system health status', async () => {\n      // Generate some activity across all systems\n      for (let i = 0; i < 5; i++) {\n        await performanceMonitor.timeFunction(\n          'health_check_operation',\n          async () => {\n            const schedule = await generator.generateOptimizedSchedule(\n              mockCourses.slice(0, 3),\n              mockTeachers.slice(0, 2),\n              mockGroups.slice(0, 3),\n              { maxLessonsPerDay: 4, lessonDuration: 45 }\n            );\n            \n            cacheService.set('schedule', `health_test_${i}`, schedule);\n            return schedule;\n          }\n        );\n      }\n\n      // Get health reports from all systems\n      const performanceReport = performanceMonitor.generateReport();\n      const cacheHealth = cacheService.getHealthReport();\n      const errorReport = errorRecovery.generateReport();\n\n      // Validate all reports are meaningful\n      expect(performanceReport.summary.totalOperations).toBeGreaterThan(0);\n      expect(cacheHealth.overall.totalHitRate).toBeGreaterThanOrEqual(0);\n      expect(errorReport.healthStatus).toMatch(/healthy|degraded|critical/);\n      \n      // Overall system should be healthy\n      const hasPerformanceAlerts = performanceReport.alerts.length > 0;\n      const hasCacheIssues = cacheHealth.recommendations.some(r => r.includes('critical'));\n      const hasErrorIssues = errorReport.healthStatus === 'critical';\n      \n      // At least one system should report good health\n      const systemsHealthy = !hasPerformanceAlerts || !hasCacheIssues || !hasErrorIssues;\n      expect(systemsHealthy).toBe(true);\n    });\n  });\n});"